МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ

Кафедра програмної інженерії




Практична робота №1
з дисципліни: «Архітектура програмного забезпечення»
на тему: «Шаблон (патерн) проєктування "Observer" (Спостерігач)»




Виконала:
ст. гр. ПЗПІ-22-8
Судакова А.Д.
Перевірив:
ст. викл. кафедри ПІ
Сокорчук І.П.





Харків 2025
     1 ІСТОРІЯ ЗМІН
     
     У цьому розділі представлено історію внесених змін до звіту, що наведено у табл. 1.
     
     Таблиця 1 – Історія змін
№
Дата
Версія
Опис змін
Автор
1
15.03.2025
0.1
Створено розділ «Завдання»
Альона Судакова
2
15.03.2025
0.1
Створено розділ «Опис виконаної роботи»
Альона Судакова
3
16.03.2025
0.1
Створено розділ «Висновки»
Альона Судакова
4
16.03.2025
0.1
Додано посилання на відеозапис та його хронологічний опис до додатку А
Альона Судакова
5
16.03.2025
0.1
Додано слайди презентації до додатку Б
Альона Судакова
6
16.03.2025
0.1
Додано програмний код до додатку В
Альона Судакова
7
17.03.2025
1.1
Внесено зміни у найменування розділів
Альона Судакова
8
17.03.2025
1.1
Описано розділ «Завдання»
Альона Судакова
     


     2 ЗАВДАННЯ
     
     У рамках практичної роботи №1 з дисципліни «Архітектура програмного забезпечення» було поставлено завдання дослідити та вивчити патерн проєктування Observer (Спостерігач). Це потребувало глибокого аналізу даного патерну з точки зору його структури, основних принципів та практичного застосування в реальних проєктах.
     Необхідно було ознайомитися з теоретичною базою патерну Observer, зрозуміти його місце в загальній класифікації патернів проєктування (поведінкові патерни) та визначити основні компоненти, з яких він складається. Потрібно було вивчити механізм взаємодії між видавцем (Publisher/Subject) та підписниками (Observers), зрозуміти принципи встановлення зв'язків між цими компонентами та процес оповіщення підписників про зміни в стані видавця.
     Важливою частиною завдання було також визначення ситуацій, у яких доцільно застосовувати патерн Observer, аналіз його переваг та потенційних недоліків.
     Загалом, завдання було спрямоване на комплексне вивчення патерну проєктування Observer, розвиток навичок аналізу та реалізації патернів проєктування, а також удосконалення вмінь представлення технічної інформації через презентацію та усну доповідь.
     


     3 ОПИС ВИКОНАНОЇ РОБОТИ
     
     У процесі роботи було досліджено та проаналізовано паттерн проєктування "Observer" (Спостерігач). Цей паттерн належить до категорії поведінкових патернів проєктування, описаних у книзі "Шаблони проєктування" (Gang of Four).
     3.1 Сутність патерну "Observer":
     Observer — це поведінковий патерн проєктування, який створює механізм підписки, що дозволяє одним об'єктам (спостерігачам) стежити і реагувати на події, що відбуваються в інших об'єктах (суб'єктах або об'єктах, що спостерігаються).
     Патерн Observer вирішує такі проблеми як визначення залежності "один-до-багатьох" між об'єктами, коли при зміні стану одного об'єкта автоматично оновлюються всі залежні від нього об'єкти та забезпечення слабкого зв'язування між компонентами системи.
     3.2 Структура патерну
     Патерн Observer складається з наступних компонентів:
     Subject (Observable) – інтерфейс або абстрактний клас, який визначає методи для підключення та відключення спостерігачів, а також метод для оповіщення всіх зареєстрованих спостерігачів.
     Observer – інтерфейс або абстрактний клас, який визначає метод оновлення, що викликається при зміні стану суб'єкта спостереження.
     ConcreteSubject – конкретний клас, який реалізує інтерфейс Subject і містить стан, що цікавить спостерігачів. При зміні свого стану відправляє повідомлення спостерігачам.
     ConcreteObserver – конкретний клас, який реалізує інтерфейс Observer і отримує оновлення від суб'єкта спостереження. Може зберігати посилання на конкретний суб'єкт.
     3.3 Принцип роботи патерну
     Суб'єкт (Subject) підтримує список спостерігачів і надає методи для додавання і видалення спостерігачів з цього списку.
     Коли стан суб'єкта змінюється, він повідомляє всіх спостерігачів, викликаючи метод оновлення на кожному з них.
     Спостерігачі отримують оновлення і реагують відповідно до своєї логіки.
     3.4. Застосовність
     Патерн Observer використовується в наступних випадках:
     - Коли зміни стану одного об'єкта можуть вимагати зміни в інших об'єктах, і заздалегідь невідомо, які саме об'єкти потрібно змінити.
     - Коли об'єкт повинен оповіщати інші об'єкти, не припускаючи, що ці об'єкти належать до певних класів (дотримання принципу слабкого зв'язування).
     - Коли абстракції у програмі мають два аспекти, один з яких залежить від іншого.
     3.5 Переваги та недоліки
     Переваги:
     - Дотримання принципу відкритості/закритості — можна вводити нові класи спостерігачів без зміни коду суб'єкта.
     - Встановлення зв'язків між об'єктами під час виконання програми.
     - Зменшення зв'язаності між компонентами системи.
     До недоліків можна віднести:
     - Суб'єкти можуть відправляти оновлення, які не цікавлять конкретних спостерігачів.
     - Випадкова зміна порядку оповіщення спостерігачів може призвести до непередбачуваних результатів.
     - Можливе створення циклічних залежностей, якщо спостерігачі також виступають як суб'єкти.
     3.6 Реальні приклади використання
     Патерн Observer широко використовується в різних областях програмування. У графічних інтерфейсах користувача (GUI) компоненти інтерфейсу підписуються на події від кнопок, списків, полів введення тощо. Розглядаючи системи подій у веб-браузерах, JavaScript підтримує модель подій, де можна підписатися на події DOM-елементів.
     В архітектурах MVC (Model-View-Controller) представлення (View) підписуються на зміни моделі (Model).
     Системи реактивного програмування, такі фреймворки, як RxJS, також базуються на патерні Observer.
     3.7 Реалізація патерну на TypeScript
     Було розроблено приклад реалізації патерну Observer на мові TypeScript (додаток В), який демонструє систему сповіщень для новинного порталу. У цьому прикладі реалізовано типову структуру патерну Observer: 
     NewsPublisher виступає як Видавець (Subject/Publisher), який зберігає список підписників, надає методи для додавання та видалення підписників, сповіщає всіх підписників про нові новини та зберігає стан (останню опубліковану новину), що цікавить підписників 
     EmailSubscriber та MobileAppSubscriber є конкретними Підписниками (Concrete Observers), які реалізують інтерфейс Observer з методом update(), реагують на оновлення по-різному: один надсилає email, інший - push-сповіщення. Також вони мають доступ до стану Видавця через посилання, що передається в метод update().
     Цей приклад демонструє ключові переваги патерну Observer такі як слабке зв'язування між Видавцем та Підписниками, можливість додавати нових Підписників без зміни коду Видавця та динамічне встановлення зв'язків між об'єктами під час виконання програми. 
     Як видно з результатів виконання, підписники отримують оновлення тільки доти, доки вони залишаються в списку підписників Видавця. Коли підписника видаляють зі списку, він більше не отримує оповіщень про нові події.
     


     4 ВИСНОВКИ З РОБОТИ
     
     Під час роботи було детально розібрано, що уявляє собою паттерн Observer (Спостерігач), коли він застосовується, його структуру та застосовність. Було розглянуто схему його використання, переваги та недоліки, його споріднені паттерни та наведено приклади застосування цього паттерну у вигляді коду на TypeScript.
     Використання патерну Observer дозволяє дотримуватися принципів SOLID, зокрема принципу відкритості/закритості та принципу інверсії залежностей, що робить систему більш гнучкою та розширюваною.


     ДОДАТОК А
     Відеозапис доповіді на YouTube: https://youtu.be/uD_e0N-9OWU
     00:00 Вступ: представлення теми доповіді про патерн проєктування "Observer", огляд структури презентації та ключових питань, що будуть розглянуті
     00:25 Що таке Observer (Спостерігач): Визначення патерну Observer як поведінкового патерну, що створює механізм підписки для спостереження одними об'єктами за подіями в інших
     00:38 Коли патерн Observer застосовується: Розбір випадків застосування патерну Observer з прикладами ситуацій, коли його використання найбільш доцільне
     01:25 Структура: Пояснення структури патерну Observer з ілюстрацією класів та об'єктів, їх взаємодії
     01:35 Учасники: Характеристика учасників патерну - видавця (publisher), підписника (subscriber) та опис їхніх обов'язків у схемі взаємодії
     02:37 Схема використання: Демонстрація схеми використання патерну Observer
     03:21 Обговорення прикладу з реального життя про підписку на новини як ілюстрації принципів роботи патерну Observer
     04:14 Аналіз переваг та недоліків патерну Observer
     05:15 Приклади реалізації патерну Observer на TypeScript для системи новинних сповіщень
     06:06 Аналіз використання патерну Observer у сучасних технологіях
     06:36 Підсумки та висновки щодо корисності патерну Observer
     07:13 Використані джерела

     ДОДАТОК Б
     Слайди презентації доповіді
     
     
     Рисунок Б.1 – Титульний слайд презентації
     
     
     Рисунок Б.2 – Зміст презентації
     
     
     Рисунок Б.3 – Визначення патерну «Спостерігач»

     
     Рисунок Б.4 – Ситуації використання патерну «Спостерігач»
     
     
     
     Рисунок Б.5 – Структура патерну «Спостерігач»
     
     
     Рисунок Б.6 – Характеристика учасників патерну
     
     
     
     Рисунок Б.7 – Опис обов'язків учасників у схемі взаємодії
     
     
     Рисунок Б.8 – Схема використання патерну «Спостерігач»
     
     
     
     Рисунок Б.9 – Наведення прикладу використання
     
     
     Рисунок Б.10 – Переваги та недоліки використання патерну
     
     
     Рисунок Б.11 – Приклад реалізації патерну Observer мовою TypeScript
     
     
     Рисунок Б.12 – Аналіз використання патерну Observer у сучасних технологіях
     
     
     Рисунок Б.13 – Підсумки та висновки щодо корисності патерну Observer
     
     
     Рисунок Б.14 – Використані джерела
     
     
     Рисунок Б.15 – Заключний слайд
     

     ДОДАТОК В
     Програмний код
     
      1  /**
      2  * Інтерфейс Підписника визначає метод update, який викликається 
      3  * Видавцем при зміні його стану
      4  */
      5 interface Observer {
      6     update(subject: Subject): void;
      7 }
      8 
      9 /**
      10  * Інтерфейс Видавця оголошує набір методів для керування підписниками
      11  */
      12 interface Subject {
      13     // Приєднує підписника до видавця
      14     attach(observer: Observer): void;
      15     
      16     // Відʼєднує підписника від видавця
      17     detach(observer: Observer): void;
      18     
      19     // Оповіщає всіх підписників про подію
      20     notify(): void;
      21 }
      22 
      23 /**
      24  * Конкретний Видавець містить деякий важливий стан і оповіщає підписників,
      25  * коли цей стан змінюється
      26  */
      27 class NewsPublisher implements Subject {
      28     // Список підписників. У реальному житті список підписників може зберігатися
      29     // в більш детальному вигляді (за типом події тощо)
      30     private observers: Observer[] = [];
      31     
      32     // Стан Видавця, що цікавить підписників
      33     private latestNews: string = "";
      34 
      35     /**
      36      * Приєднує нового підписника до списку
      37      */
      38     public attach(observer: Observer): void {
      39         const isExist = this.observers.includes(observer);
      40         if (isExist) {
      41             return console.log('Підписник вже приєднаний');
      42         }
      43         
      44         this.observers.push(observer);
      45         console.log('Підписник приєднаний');
      46     }
      47 
      48     /**
      49      * Відʼєднує підписника від списку
      50      */
      51     public detach(observer: Observer): void {
      52         const observerIndex = this.observers.indexOf(observer);
      53         
      54         if (observerIndex === -1) {
      55             return console.log('Такого підписника не існує');
      56         }
      57         
      58         this.observers.splice(observerIndex, 1);
      59         console.log('Підписник відʼєднаний');
      60     }
      61 
      62     /**
      63      * Оповіщає всіх підписників про зміну стану
      64      */
      65     public notify(): void {
      66         console.log('Оповіщення всіх підписників...');
      67         
      68         for (const observer of this.observers) {
      69             observer.update(this);
      70         }
      71     }
      72 
      73     /**
      74      * Зазвичай логіка Видавця є частиною бізнес-логіки програми.
      75      * У цьому прикладі видавець публікує нову новину, що змінює
      76      * його стан і запускає оповіщення
      77      */
      78     public publishNews(news: string): void {
      79         this.latestNews = news;
      80         console.log(`NewsPublisher: Опубліковано нову новину: ${news}`);
      81         this.notify();
      82     }
      83 
      84     /**
      85      * Метод, що дозволяє підписникам отримати поточний стан видавця
      86      */
      87     public getLatestNews(): string {
      88         return this.latestNews;
      89     }
      90 }
      91 
      92 /**
      93  * Конкретні Підписники реагують на оновлення, що випускає Видавець,
      94  * до якого вони були приєднані
      95  */
      96 class EmailSubscriber implements Observer {
      97     private email: string;
      98 
      99     constructor(email: string) {
      100         this.email = email;
      101     }
      102 
      103     /**
      104      * Отримує оновлення від видавця
      105      */
      106     public update(subject: NewsPublisher): void {
      107         if (subject instanceof NewsPublisher) {
      108             console.log(`EmailSubscriber ${this.email}: Отримано нову новину: ${subject.getLatestNews()}`);
      109         }
      110     }
      111 }
      112 
      113 /**
      114  * Інший тип Конкретного Підписника, який реагує на оновлення по-своєму
      115  */
      116 class MobileAppSubscriber implements Observer {
      117     private userId: string;
      118 
      119     constructor(userId: string) {
      120         this.userId = userId;
      121     }
      122 
      123     /**
      124      * Отримує оновлення від видавця і відправляє push-сповіщення
      125      */
      126     public update(subject: NewsPublisher): void {
      127         if (subject instanceof NewsPublisher) {
      128             console.log(`MobileAppSubscriber ${this.userId}: Надіслано push-сповіщення про новину: ${subject.getLatestNews()}`);
      129         }
      130     }
      131 }
      132 
      133 /**
      134  * Клієнтський код
      135  */
      136 function demoObserverPattern(): void {
      137     // Створюємо видавця
      138     const publisher = new NewsPublisher();
      139 
      140     // Створюємо підписників
      141     const emailSubscriber1 = new EmailSubscriber("john@example.com");
      142     const emailSubscriber2 = new EmailSubscriber("jane@example.com");
      143     const mobileSubscriber = new MobileAppSubscriber("user_123");
      144 
      145     // Додаємо підписників до видавця
      146     publisher.attach(emailSubscriber1);
      147     publisher.attach(emailSubscriber2);
      148     publisher.attach(mobileSubscriber);
      149 
      150     // Публікуємо новину - всі підписники будуть оповіщені
      151     publisher.publishNews("Нова версія TypeScript 5.0 випущена!");
      152 
      153     console.log("\n");
      154 
      155     // Відключаємо одного підписника
      156     publisher.detach(emailSubscriber1);
      157 
      158     // Публікуємо ще одну новину - тільки активні підписники отримають оповіщення
      159     publisher.publishNews("Анонсовано нові функції в ECMAScript 2023");
      160 }
      161 
      162 // Запуск демонстрації
      163 demoObserverPattern();
      164 
      165 /**
      166  * Виведення в консоль:
      167  * 
      168  * Підписник приєднаний
      169  * Підписник приєднаний
      170  * Підписник приєднаний
      171  * NewsPublisher: Опубліковано нову новину: Нова версія TypeScript 5.0 випущена!
      172  * Оповіщення всіх підписників...
      173  * EmailSubscriber john@example.com: Отримано нову новину: Нова версія TypeScript 5.0 випущена!
      174  * EmailSubscriber jane@example.com: Отримано нову новину: Нова версія TypeScript 5.0 випущена!
      175  * MobileAppSubscriber user_123: Надіслано push-сповіщення про новину: Нова версія TypeScript 5.0 випущена!
      176  * 
      177  * Підписник відʼєднаний
      178  * NewsPublisher: Опубліковано нову новину: Анонсовано нові функції в ECMAScript 2023
      179  * Оповіщення всіх підписників...
      180  * EmailSubscriber jane@example.com: Отримано нову новину: Анонсовано нові функції в ECMAScript 2023
      181  * MobileAppSubscriber user_123: Надіслано push-сповіщення про новину: Анонсовано нові функції в ECMAScript 2023
      182  */
2


